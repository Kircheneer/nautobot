"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, Optional

from django.views.generic.list import ListView

class TableMixinBase:
    """
    Base mixin for the Single- and MultiTable class based views.
    """

    context_table_name = ...
    table_pagination = ...
    def get_context_table_name(self, table):  # -> str:
        """
        Get the name to use for the table's template variable.
        """
        ...

    def get_table_pagination(self, table):  # -> dict[Unknown, Unknown] | bool:
        """
        Return pagination options passed to `.RequestConfig`:
            - True for standard pagination (default),
            - False for no pagination,
            - a dictionary for custom pagination.

        `ListView`s pagination attributes are taken into account, if `table_pagination` does not
        define the corresponding value.

        Override this method to further customize pagination for a `View`.
        """
        ...

    def get_paginate_by(self, table_data) -> Optional[int]:
        """
        Determines the number of items per page, or ``None`` for no pagination.

        Args:
            table_data: The table's data.

        Returns:
            Optional[int]: Items per page or ``None`` for no pagination.
        """
        ...

class SingleTableMixin(TableMixinBase):
    """
    Adds a Table object to the context. Typically used with
    `.TemplateResponseMixin`.

    Attributes:
        table_class: subclass of `.Table`
        table_data: data used to populate the table, any compatible data source.
        context_table_name(str): name of the table's template variable (default:
            'table')
        table_pagination (dict): controls table pagination. If a `dict`, passed as
            the *paginate* keyword argument to `.RequestConfig`. As such, any
            Truthy value enables pagination. (default: enable pagination).

            The `dict` can be used to specify values for arguments for the call to
            `~.tables.Table.paginate`.

            If you want to use a non-standard paginator for example, you can add a key
            `paginator_class` to the dict, containing a custom `Paginator` class.

    This mixin plays nice with the Django's ``.MultipleObjectMixin`` by using
    ``.get_queryset`` as a fall back for the table data source.
    """

    table_class = ...
    table_data = ...
    def get_table_class(self):  # -> Any:
        """
        Return the class to use for the table.
        """
        ...

    def get_table(self, **kwargs):
        """
        Return a table object to use. The table has automatic support for
        sorting and pagination.
        """
        ...

    def get_table_data(self):
        """
        Return the table data that should be used to populate the rows.
        """
        ...

    def get_table_kwargs(self):  # -> dict[Unknown, Unknown]:
        """
        Return the keyword arguments for instantiating the table.

        Allows passing customized arguments to the table constructor, for example,
        to remove the buttons column, you could define this method in your View::

            def get_table_kwargs(self):
                return {
                    'exclude': ('buttons', )
                }
        """
        ...

    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Overridden version of `.TemplateResponseMixin` to inject the table into
        the template's context.
        """
        ...

class SingleTableView(SingleTableMixin, ListView):
    """
    Generic view that renders a template and passes in a `.Table` instances.

    Mixes ``.SingleTableMixin`` with ``django.views.generic.list.ListView``.
    """

    ...

class MultiTableMixin(TableMixinBase):
    """
    Add a list with multiple Table object's to the context. Typically used with
    `.TemplateResponseMixin`.

    The `tables` attribute must be either a list of `.Table` instances or
    classes extended from `.Table` which are not already instantiated. In that
    case, `get_tables_data` must be able to return the tables data, either by
    having an entry containing the data for each table in `tables`, or by
    overriding this method in order to return this data.

    Attributes:
        tables: list of `.Table` instances or list of `.Table` child objects.
        tables_data: if defined, `tables` is assumed to be a list of table
            classes which will be instantiated with the corresponding item from
            this list of `.TableData` instances.
        table_prefix(str): Prefix to be used for each table. The string must
            contain one instance of `{}`, which will be replaced by an integer
            different for each table in the view. Default is 'table_{}-'.
        context_table_name(str): name of the table's template variable (default:
            'tables')

    .. versionadded:: 1.2.3
    """

    tables = ...
    tables_data = ...
    table_prefix = ...
    context_table_name = ...
    def get_tables(self):  # -> list[Unknown]:
        """
        Return an array of table instances containing data.
        """
        ...

    def get_tables_data(self):  # -> None:
        """
        Return an array of table_data that should be used to populate each table
        """
        ...

    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]: ...
